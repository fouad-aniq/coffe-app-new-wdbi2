package com.wordpressclone.adapters.secondary;  import com.wordpressclone.domain.ports.TermRepositoryPort; import com.wordpressclone.domain.entities.CategoryAggregate; import com.wordpressclone.domain.entities.TermEntity; import com.wordpressclone.domain.entities.TermTaxonomyEntity; import com.wordpressclone.domain.entities.TermMetaEntity; import com.wordpressclone.application.dtos.CategoryQueryParams; import org.springframework.stereotype.Repository; import org.springframework.transaction.annotation.Transactional;  import javax.persistence.EntityManager; import javax.persistence.PersistenceContext; import javax.persistence.PersistenceException; import javax.persistence.TypedQuery; import javax.persistence.criteria.CriteriaBuilder; import javax.persistence.criteria.CriteriaQuery; import javax.persistence.criteria.Predicate; import javax.persistence.criteria.Root; import java.util.ArrayList; import java.util.List; import java.util.Optional; import java.util.stream.Collectors;  import org.slf4j.Logger; import org.slf4j.LoggerFactory;  @Repository @Transactional public class TermRepositoryImpl implements TermRepositoryPort {      private static final Logger logger = LoggerFactory.getLogger(TermRepositoryImpl.class);      @PersistenceContext     private EntityManager entityManager;      @Override     @Transactional(readOnly = true)     public List<CategoryAggregate> findAllCategories(CategoryQueryParams queryParams) {         logger.info("Fetching all categories from the database with filters");         try {             CriteriaBuilder cb = entityManager.getCriteriaBuilder();             CriteriaQuery<TermTaxonomyEntity> cq = cb.createQuery(TermTaxonomyEntity.class);             Root<TermTaxonomyEntity> termTaxonomy = cq.from(TermTaxonomyEntity.class);             List<Predicate> predicates = new ArrayList<>();             if (queryParams.getSearch() != null) {                 predicates.add(cb.like(termTaxonomy.get("name"), "%" + queryParams.getSearch() + "%"));             }             // Add more predicates based on other queryParams fields             if (!predicates.isEmpty()) {                 cq.where(cb.and(predicates.toArray(new Predicate[0])));             }             cq.select(termTaxonomy).where(cb.equal(termTaxonomy.get("taxonomy"), "category"));             TypedQuery<TermTaxonomyEntity> query = entityManager.createQuery(cq);             List<TermTaxonomyEntity> taxonomies = query.getResultList();             return taxonomies.stream()                 .map(taxonomy -> buildCategoryAggregate(entityManager.find(TermEntity.class, taxonomy.getTermId())))                 .filter(Optional::isPresent)                 .map(Optional::get)                 .collect(Collectors.toList());         } catch (PersistenceException e) {             logger.error("Error fetching all categories", e);             throw new RuntimeException("Failed to fetch all categories", e);         }     }      @Override     @Transactional(readOnly = true)     public CategoryAggregate findCategoryById(Long id) {         logger.info("Fetching category by ID: {}", id);         try {             TermEntity term = entityManager.find(TermEntity.class, id);             if (term == null) {                 logger.warn("No term found for ID: {}", id);                 return null;             }             return buildCategoryAggregate(term).orElse(null);         } catch (PersistenceException e) {             logger.error("Error retrieving category by id: {}", id, e);             throw new RuntimeException("Failed to retrieve category", e);         }     }      @Override     @Transactional     public TermEntity saveTerm(TermEntity term) {         logger.info("Saving term: {}", term);         try {             if (term.getId() == null) {                 entityManager.persist(term);             } else {                 term = entityManager.merge(term);             }             return term;         } catch (PersistenceException e) {             logger.error("Error saving term: {}", term, e);             throw new RuntimeException("Failed to save term", e);         }     }      @Override     @Transactional     public TermTaxonomyEntity saveTermTaxonomy(TermTaxonomyEntity termTaxonomy) {         logger.info("Saving term taxonomy: {}", termTaxonomy);         try {             if (termTaxonomy.getId() == null) {                 entityManager.persist(termTaxonomy);             } else {                 termTaxonomy = entityManager.merge(termTaxonomy);             }             return termTaxonomy;         } catch (PersistenceException e) {             logger.error("Error saving term taxonomy: {}", termTaxonomy, e);             throw new RuntimeException("Failed to save term taxonomy", e);         }     }      @Override     @Transactional     public TermMetaEntity saveTermMeta(TermMetaEntity termMeta) {         logger.info("Saving term meta: {}", termMeta);         try {             if (termMeta.getId() == null) {                 entityManager.persist(termMeta);             } else {                 termMeta = entityManager.merge(termMeta);             }             return termMeta;         } catch (PersistenceException e) {             logger.error("Error saving term meta: {}", termMeta, e);             throw new RuntimeException("Failed to save term meta", e);         }     }      private Optional<CategoryAggregate> buildCategoryAggregate(TermEntity term) {         logger.info("Building category aggregate for term: {}", term);         if (term == null) {             logger.warn("Received null term in buildCategoryAggregate");             return Optional.empty();         }         TermTaxonomyEntity taxonomy = findTermTaxonomy(term.getId());         if (taxonomy == null) {             logger.warn("No taxonomy found for term ID: {}", term.getId());             return Optional.empty();         }         List<TermMetaEntity> metas = findTermMetas(term.getId());         if (metas.isEmpty()) {             logger.warn("No meta data found for term ID: {}", term.getId());         }         return Optional.of(new CategoryAggregate(term, taxonomy, metas));     }      private TermTaxonomyEntity findTermTaxonomy(Long termId) {         logger.info("Searching for term taxonomy with termId: {}", termId);         try {             TypedQuery<TermTaxonomyEntity> query = entityManager.createQuery(                 "SELECT tt FROM TermTaxonomyEntity tt WHERE tt.termId = :termId AND tt.taxonomy = :taxonomy",                 TermTaxonomyEntity.class             );             query.setParameter("termId", termId);             query.setParameter("taxonomy", "category");             List<TermTaxonomyEntity> results = query.getResultList();             if (results.isEmpty()) {                 logger.warn("No term taxonomy found for termId: {}", termId);                 return null;             }             return results.get(0);         } catch (PersistenceException e) {             logger.error("Error finding term taxonomy for term id: {}", termId, e);             throw a RuntimeException("Failed to find term taxonomy", e);         }     }      private List<TermMetaEntity> findTermMetas(Long termId) {         logger.info("Searching for term metas with termId: {}", termId);         try {             TypedQuery<TermMetaEntity> query = entityManager.createQuery(                 "SELECT tm FROM TermMetaEntity tm WHERE tm.termId = :termId",                 TermMetaEntity.class             );             query.setParameter("termId", termId);             List<TermMetaEntity> results = query.getResultList();             if (results.isEmpty()) {                 logger.warn("No term metas found for termId: {}", termId);             }             return results;         } catch (PersistenceException e) {             logger.error("Error finding term metas for term id: {}", termId, e);             throw a RuntimeException("Failed to find term metas", e);         }     } }